/**

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

**/


#include <iostream>
#include "resp_client.h"
#include "redis_client.h"
#include <thread>
#include <chrono>
#include <fstream>

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wsign-conversion"
#include "spdlog/spdlog.h"
#include "spdlog/sinks/stdout_color_sinks.h"
#pragma GCC diagnostic pop

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wsign-conversion"
#include "clipp.h"
#pragma GCC diagnostic pop

#include "json.hpp"

using namespace std;
using namespace std::chrono;
using namespace clipp;
using json = nlohmann::json;

void increase_balance(redis_client& client) {
  spdlog::info("Increasing balance by one.");
  client.incr("account_balance");

  std::string new_balance = client.get("account_balance");

  spdlog::info("Increased balance by one, new balance is: " + new_balance);
}

bool acquire_lock(redis_client& client, std::string key, std::string value, int expire_time) {
  if (client.setnx(key, value)) {
    client.expire(key, expire_time);
    return true;
  }

  return false;
}

void release_lock(redis_client& client, std::string key) {
  client.del(key);

  spdlog::info("Released lock: " + key);
}

void load_config_from_path(
  std::string config_path, 
  std::string& host, int& port,
  std::string& lock_key,
  std::string& lock_value,
  int& expire_time,
  int& sleep_time_ms
) {
  json config_object;
  std::ifstream config_stream(config_path);
  config_stream >> config_object;

  config_stream.close();

  if (config_object.find("host") != config_object.end()) {
    host = config_object.at("host");
  }

  if (config_object.find("port") != config_object.end()) {
    port = config_object.at("port");
  }

  if (config_object.find("lock_key") != config_object.end()) {
    lock_key = config_object.at("lock_key");
  }

  if (config_object.find("lock_value") != config_object.end()) {
    lock_value = config_object.at("lock_value");
  }

  if (config_object.find("expire_time") != config_object.end()) {
    expire_time = config_object.at("expire_time");
  }

  if (config_object.find("sleep_time_ms") != config_object.end()) {
    sleep_time_ms = config_object.at("sleep_time_ms");
  }
}

int main(int argc, char** argv) {
  std::string host{"localhost"};
  int port{6379};
  std::string lock_key{"account_balance_lock"};
  std::string lock_value{"Some random value"};
  int expire_time{1};
  int sleep_time_ms{1};
  bool show_help{false};
  std::string config_path{""};

  auto cli_config = (
      option("-h", "--hostname").doc("Hostname of Redis instance") & value("host", host),
      option("-k", "--lock-key").doc("Name of the key that will be acquired") & value("lock_key", lock_key),
      option("-v", "--lock-value").doc("Value of the key that will be acquired") & value("lock_value", lock_value),
      option("-p", "--port").doc("Port of Redis instance") & value("port", port),
      option("-s", "--sleep-time").doc("Time (ms) that the process will sleep during the acquiration of the lock") & value("sleep_time", sleep_time_ms),
      option("-e", "--expire-time").doc("Expire time (s) of the lock") & value("expire_time", expire_time),
      option("-c", "--config").doc("Path to a JSON-config file. WARNING: This will overwrite the values provided as CLI flags") & value("config_path", config_path),
      option("-h", "--help").set(show_help).doc("Show this help dialog")
  );

  if (!parse(argc, argv, cli_config) || show_help) {
      std::cout << make_man_page(cli_config, argv[0]) << std::endl;

      if (show_help) {
        return EXIT_SUCCESS;
      }

      return EXIT_FAILURE;
  }

  if (config_path != "") {
    try {
      load_config_from_path(
        config_path, host, port, 
        lock_key, lock_value,
        expire_time, sleep_time_ms
      );
    } catch(nlohmann::detail::parse_error&) {
      spdlog::error("Could not parse specified config file.");
      return EXIT_FAILURE;
    }
  }


  shared_ptr<resp_client> resp_connection = 
    make_shared<resp_client>(host, port);
  redis_client client{resp_connection};

  if (!resp_connection->is_connected()) {
    spdlog::error("Could not establish connection to Redis instance.");

    return EXIT_FAILURE;
  }

  spdlog::info("Connection is active.");

  for (;;) {
    spdlog::info("Trying to acquire lock:" + lock_key);
    while (!acquire_lock(client, lock_key, lock_value, expire_time)) {
      spdlog::info("Lock could not be acquired. Sleeping...");
      this_thread::sleep_for(milliseconds(sleep_time_ms));
      spdlog::info("Trying to acquire lock:" + lock_key);
    }

    spdlog::info("Successfully acquired lock.");
    increase_balance(client);
    release_lock(client, "account_balance_lock");
  }

  /*
  redis_connection.set("mein_key", "mein_value");
  cout << "GET: " << redis_connection.get("mein_key") << std::endl;
  redis_connection.set("mein_key", "mein_value_neu");
  cout << "GET 2: " << redis_connection.get("mein_key") << std::endl;

  cout << "SETNX: " << redis_connection.setnx("mein_key", "through SETNX") << endl;

  cout << "EXPIRE: " << redis_connection.expire("mein_key", 10) << endl;
  cout << "TTL: " << redis_connection.ttl("mein_key") << endl;

  auto lpush_status = redis_connection.lpush("values", {
    "1", "2", "3"
  });

  cout << "Lpush status: " << lpush_status << endl;

  auto values = redis_connection.lrange("values", 1, 2);

  redis_connection.send_pipelined({
    resp_types::command({"set", "a", "a"}),
    resp_types::command({"set", "mein_value", "pipelined"})
  });

  subscriber subs = redis_connection.subscribe("channel-six", 
    [&](resp_types::subscription_message message) -> auto {
      std::cout << "Channel Six Message: " << message.message << std::endl;
  });

  subscriber sub_sync = redis_connection.subscribe_sync("channel-twelve", [&sub_sync] (resp_types::subscription_message message) {
    std::cout << "Channel twelve, got message: " << message.message << std::endl;
    std::cout << "Received message, going to unsubscribe now." << std::endl;
    sub_sync.unsubscribe();
  });


  std::cout << "running transaction" << std::endl;

  redis_connection.transaction({
    resp_types::command({
      "set", "a", "1"
    }),

    resp_types::command({
      "set", "veryimportantvalue", "some important value"
    }),

    resp_types::command({
      "get", "a"
    })
  });
  */
}
